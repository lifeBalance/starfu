import type { AstroIntegration } from 'astro'
import path from 'node:path'
import { writeFileSync, mkdirSync } from 'node:fs'

type DocsSection = {
  root: string
  title?: string
  subtitle?: string
  href?: string
}

type DocsIntegrationOptions = {
  basePath?: string
  sections?: DocsSection[]
  title?: string
}

const MODULE_ID = 'virtual:docs-config'
const RESOLVED_ID = '\0virtual:docs-config'

export function normalizeRoot(root: string): string {
  const sanitized = root.replace(/\\/g, '/').replace(/^\.\//, '')
  // Keep relative paths (../) as-is, only add leading slash to absolute-style paths
  if (sanitized.startsWith('../') || sanitized.startsWith('/')) {
    return sanitized.replace(/\/$/, '')
  }
  return `/${sanitized}`.replace(/\/$/, '')
}

function normalizeSections(sections?: DocsSection[]): DocsSection[] {
  return (sections ?? [{ root: '/docs' }]).map((section) => ({
    ...section,
    root: normalizeRoot(section.root),
  }))
}

// Virtual module only contains config, NOT globs
function createDocsVirtualModule(sections: DocsSection[], basePath?: string, title?: string) {
  const baseExpr = basePath === undefined ? 'undefined' : JSON.stringify(basePath)
  const titleExpr = title === undefined ? 'undefined' : JSON.stringify(title)
  const sectionsWithId = sections.map(s => ({ ...s, id: s.root.split('/').pop()! }))
  const sectionsJson = JSON.stringify(sectionsWithId, null, 2)

  return {
    name: 'docs-virtual-config',
    enforce: 'pre' as const,
    resolveId(id: string) {
      if (id === MODULE_ID) return RESOLVED_ID
      return null
    },
    load(id: string) {
      if (id !== RESOLVED_ID) return null

      return `export const docsConfig = {
  basePath: ${baseExpr},
  title: ${titleExpr},
  branches: ${sectionsJson}
};
`
    },
  }
}

// Resolve bare imports (e.g. "astro-expressive-code/components") from docs files
// outside .starfu/ against .starfu/node_modules/
function createDocsResolverPlugin(projectRoot: string) {
  return {
    name: 'docs-resolve-deps',
    enforce: 'pre' as const,
    async resolveId(source: string, importer: string | undefined) {
      if (
        !importer ||
        !source ||
        source.startsWith('.') ||
        source.startsWith('/') ||
        source.startsWith('\0') ||
        source.startsWith('virtual:') ||
        source.startsWith('node:') ||
        importer.startsWith(projectRoot)
      ) {
        return null
      }
      // Re-resolve as if the import came from inside the project root
      return this.resolve(source, path.join(projectRoot, '_docs_resolve_.ts'), {
        skipSelf: true,
      })
    },
  }
}

// Generate a real file with globs at project root (so relative paths work correctly)
function generateRegistryFile(projectRoot: string, sections: DocsSection[]) {
  const sectionsWithId = sections.map(s => ({ ...s, id: s.root.split('/').pop()! }))

  const imports = sectionsWithId
    .map((section) => {
      const contentGlob = `${section.root}/**/*.{md,mdx}`
      const tocGlob = `${section.root}/**/_toc.ts`
      return `  '${section.id}': {
    content: import.meta.glob('${contentGlob}', { eager: true }),
    toc: import.meta.glob('${tocGlob}', { eager: true }),
  }`
    })
    .join(',\n')

  // File at project root so ../docs paths resolve correctly
  const content = `// Auto-generated by docs integration - DO NOT EDIT
export const generatedRegistry = {
${imports}
}
`

  const outPath = path.join(projectRoot, 'docs-registry.ts')
  writeFileSync(outPath, content, 'utf8')
}

export default function docsIntegration(options: DocsIntegrationOptions = {}): AstroIntegration {
  return {
    name: 'docs-integration',
    hooks: {
      'astro:config:setup': async ({ updateConfig, config }) => {
        const projectRoot = config.root.pathname
        const sections = normalizeSections(options.sections)

        // Generate a real file with globs (relative paths work from real files)
        generateRegistryFile(projectRoot, sections)

        // Resolve paths for fs.allow
        const docsRoots = sections
          .filter((s) => s.root.startsWith('../') || s.root.startsWith('./'))
          .map((s) => path.resolve(projectRoot, s.root))

        updateConfig({
          vite: {
            server: {
              fs: {
                allow: [projectRoot, ...docsRoots],
              },
            },
            plugins: [
              createDocsVirtualModule(sections, options.basePath, options.title),
              createDocsResolverPlugin(projectRoot),
            ],
          },
        })
      },
    },
  }
}
