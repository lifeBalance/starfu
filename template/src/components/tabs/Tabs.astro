---
import { processPanels } from './rehype-tabs'

interface Props {
  syncKey?: string
}

const { syncKey } = Astro.props
const panelHtml = await Astro.slots.render('default')
const { html, panels } = processPanels(panelHtml)

const isSynced = syncKey !== undefined
const didRenderSyncedTabsRestoreScriptSymbol = Symbol.for('starfu:did-render-synced-tabs-restore-script')
// @ts-expect-error - using symbol on Astro.locals
const shouldRenderSyncedTabsRestoreScript = isSynced && Astro.locals[didRenderSyncedTabsRestoreScriptSymbol] !== true

if (isSynced) {
  // @ts-expect-error - using symbol on Astro.locals
  Astro.locals[didRenderSyncedTabsRestoreScriptSymbol] = true
}
---

{shouldRenderSyncedTabsRestoreScript && <script is:inline>
(() => {
  class StarfuTabsRestore extends HTMLElement {
    connectedCallback() {
      const tabs = this.closest('starfu-tabs');
      if (!(tabs instanceof HTMLElement) || typeof localStorage === 'undefined') return;
      const syncKey = tabs.dataset.syncKey;
      if (!syncKey) return;
      const label = localStorage.getItem(`starfu-synced-tabs__${syncKey}`);
      if (!label) return;
      const tabLinks = [...tabs.querySelectorAll('[role="tab"]')];
      const tabIndexToRestore = tabLinks.findIndex(
        (tab) => tab instanceof HTMLAnchorElement && tab.textContent?.trim() === label
      );
      const panels = tabs.querySelectorAll(':scope > [role="tabpanel"]');
      const newTab = tabLinks[tabIndexToRestore];
      const newPanel = panels[tabIndexToRestore];
      if (tabIndexToRestore < 1 || !newTab || !newPanel) return;
      tabLinks[0]?.setAttribute('aria-selected', 'false');
      tabLinks[0]?.setAttribute('tabindex', '-1');
      panels?.[0]?.setAttribute('hidden', 'true');
      newTab.removeAttribute('tabindex');
      newTab.setAttribute('aria-selected', 'true');
      newPanel.removeAttribute('hidden');
    }
  }
  customElements.define('starfu-tabs-restore', StarfuTabsRestore);
})()
</script>}

<starfu-tabs data-sync-key={syncKey} class="block my-4">
  {
    panels && (
      <div class="overflow-x-auto not-prose">
        <ul role="tablist" class="flex list-none border-b-2 border-gray-200 dark:border-gray-700 p-0 m-0">
          {panels.map(({ label, panelId, tabId }, idx) => (
            <li role="presentation" class="flex">
              <a
                role="tab"
                href={'#' + panelId}
                id={tabId}
                aria-selected={idx === 0 ? 'true' : 'false'}
                tabindex={idx !== 0 ? -1 : 0}
                class:list={[
                  'flex items-center px-4 py-2 text-sm no-underline transition-colors',
                  'border-b-2 -mb-0.5',
                  'text-gray-600 dark:text-gray-400 border-transparent',
                  'hover:text-gray-900 dark:hover:text-gray-200',
                  'aria-selected:text-blue-600 dark:aria-selected:text-blue-400',
                  'aria-selected:border-blue-600 dark:aria-selected:border-blue-400',
                  'aria-selected:font-semibold',
                  'focus:outline-none focus-visible:ring-2 focus-visible:ring-blue-500 focus-visible:ring-offset-2',
                ]}
              >
                {label}
              </a>
            </li>
          ))}
        </ul>
      </div>
    )
  }
  <Fragment set:html={html} />
  {isSynced && <starfu-tabs-restore />}
</starfu-tabs>

<script>
  class StarfuTabs extends HTMLElement {
    static #syncedTabs = new Map<string, StarfuTabs[]>()

    tabs: HTMLAnchorElement[]
    panels: HTMLElement[]
    #syncKey: string | undefined
    #storageKeyPrefix = 'starfu-synced-tabs__'

    constructor() {
      super()
      const tablist = this.querySelector<HTMLUListElement>('[role="tablist"]')!
      this.tabs = [...tablist.querySelectorAll<HTMLAnchorElement>('[role="tab"]')]
      this.panels = [...this.querySelectorAll<HTMLElement>(':scope > [role="tabpanel"]')]
      this.#syncKey = this.dataset.syncKey

      if (this.#syncKey) {
        const syncedTabs = StarfuTabs.#syncedTabs.get(this.#syncKey) ?? []
        syncedTabs.push(this)
        StarfuTabs.#syncedTabs.set(this.#syncKey, syncedTabs)
      }

      this.tabs.forEach((tab, i) => {
        tab.addEventListener('click', (e) => {
          e.preventDefault()
          const currentTab = tablist.querySelector('[aria-selected="true"]')
          if (e.currentTarget !== currentTab) {
            this.switchTab(e.currentTarget as HTMLAnchorElement, i)
          }
        })
      })
    }

    switchTab(newTab: HTMLAnchorElement | null | undefined, index: number, shouldSync = true) {
      if (!newTab) return

      const previousTabsOffset = shouldSync ? this.getBoundingClientRect().top : 0

      this.tabs.forEach((tab) => {
        tab.setAttribute('aria-selected', 'false')
        tab.setAttribute('tabindex', '-1')
      })
      this.panels.forEach((oldPanel) => {
        oldPanel.hidden = true
      })

      const newPanel = this.panels[index]
      if (newPanel) newPanel.hidden = false
      newTab.removeAttribute('tabindex')
      newTab.setAttribute('aria-selected', 'true')
      if (shouldSync) {
        newTab.focus()
        StarfuTabs.#syncTabs(this, newTab)
        window.scrollTo({
          top: window.scrollY + (this.getBoundingClientRect().top - previousTabsOffset),
          behavior: 'instant',
        })
      }
    }

    #persistSyncedTabs(label: string) {
      if (!this.#syncKey || typeof localStorage === 'undefined') return
      localStorage.setItem(this.#storageKeyPrefix + this.#syncKey, label)
    }

    static #syncTabs(emitter: StarfuTabs, newTab: HTMLAnchorElement) {
      const syncKey = emitter.#syncKey
      const label = StarfuTabs.#getTabLabel(newTab)
      if (!syncKey || !label) return
      const syncedTabs = StarfuTabs.#syncedTabs.get(syncKey)
      if (!syncedTabs) return

      for (const receiver of syncedTabs) {
        if (receiver === emitter) continue
        const labelIndex = receiver.tabs.findIndex((tab) => StarfuTabs.#getTabLabel(tab) === label)
        if (labelIndex === -1) continue
        receiver.switchTab(receiver.tabs[labelIndex], labelIndex, false)
      }

      emitter.#persistSyncedTabs(label)
    }

    static #getTabLabel(tab: HTMLAnchorElement) {
      return tab.textContent?.trim()
    }
  }

  customElements.define('starfu-tabs', StarfuTabs)
</script>
